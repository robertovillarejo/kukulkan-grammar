/*
 * generated by Xtext 2.13.0
 */
package mx.infotec.dads.kukulkan.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mx.infotec.dads.kukulkan.kukulkan.KukulkanPackage;
import mx.infotec.dads.kukulkan.kukulkan.associationField;
import mx.infotec.dads.kukulkan.kukulkan.blobFieldType;
import mx.infotec.dads.kukulkan.kukulkan.blobValidators;
import mx.infotec.dads.kukulkan.kukulkan.booleanFieldType;
import mx.infotec.dads.kukulkan.kukulkan.dateFieldType;
import mx.infotec.dads.kukulkan.kukulkan.domainModel;
import mx.infotec.dads.kukulkan.kukulkan.entity;
import mx.infotec.dads.kukulkan.kukulkan.numericFieldType;
import mx.infotec.dads.kukulkan.kukulkan.numericValidators;
import mx.infotec.dads.kukulkan.kukulkan.primitiveField;
import mx.infotec.dads.kukulkan.kukulkan.stringFieldType;
import mx.infotec.dads.kukulkan.kukulkan.stringValidators;
import mx.infotec.dads.kukulkan.services.KukulkanGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KukulkanSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KukulkanGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KukulkanPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KukulkanPackage.ASSOCIATION_FIELD:
				sequence_associationField(context, (associationField) semanticObject); 
				return; 
			case KukulkanPackage.BLOB_FIELD_TYPE:
				sequence_blobFieldType(context, (blobFieldType) semanticObject); 
				return; 
			case KukulkanPackage.BLOB_VALIDATORS:
				sequence_blobValidators(context, (blobValidators) semanticObject); 
				return; 
			case KukulkanPackage.BOOLEAN_FIELD_TYPE:
				sequence_booleanFieldType(context, (booleanFieldType) semanticObject); 
				return; 
			case KukulkanPackage.DATE_FIELD_TYPE:
				sequence_dateFieldType(context, (dateFieldType) semanticObject); 
				return; 
			case KukulkanPackage.DOMAIN_MODEL:
				sequence_domainModel(context, (domainModel) semanticObject); 
				return; 
			case KukulkanPackage.ENTITY:
				sequence_entity(context, (entity) semanticObject); 
				return; 
			case KukulkanPackage.NUMERIC_FIELD_TYPE:
				sequence_numericFieldType(context, (numericFieldType) semanticObject); 
				return; 
			case KukulkanPackage.NUMERIC_VALIDATORS:
				sequence_numericValidators(context, (numericValidators) semanticObject); 
				return; 
			case KukulkanPackage.PRIMITIVE_FIELD:
				sequence_primitiveField(context, (primitiveField) semanticObject); 
				return; 
			case KukulkanPackage.STRING_FIELD_TYPE:
				sequence_stringFieldType(context, (stringFieldType) semanticObject); 
				return; 
			case KukulkanPackage.STRING_VALIDATORS:
				sequence_stringValidators(context, (stringValidators) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     entityField returns associationField
	 *     associationField returns associationField
	 *
	 * Constraint:
	 *     (type=cardinality toSourcePropertyName=ID? id=ID targetEntity=[entity|ID])
	 */
	protected void sequence_associationField(ISerializationContext context, associationField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns blobFieldType
	 *     blobFieldType returns blobFieldType
	 *
	 * Constraint:
	 *     (name=blobTypes constraints+=blobValidators*)
	 */
	protected void sequence_blobFieldType(ISerializationContext context, blobFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     blobValidators returns blobValidators
	 *
	 * Constraint:
	 *     (required=requiredValidator | minBytesValue=minValidator | maxBytesValue=maxValidator)
	 */
	protected void sequence_blobValidators(ISerializationContext context, blobValidators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns booleanFieldType
	 *     booleanFieldType returns booleanFieldType
	 *
	 * Constraint:
	 *     (name=BOOLEAN_TYPE required=requiredValidator?)
	 */
	protected void sequence_booleanFieldType(ISerializationContext context, booleanFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns dateFieldType
	 *     dateFieldType returns dateFieldType
	 *
	 * Constraint:
	 *     (type=dateTypes required=requiredValidator?)
	 */
	protected void sequence_dateFieldType(ISerializationContext context, dateFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     domainModel returns domainModel
	 *
	 * Constraint:
	 *     entities+=entity+
	 */
	protected void sequence_domainModel(ISerializationContext context, domainModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     entity returns entity
	 *
	 * Constraint:
	 *     (name=ID tableName=ID? (fields+=entityField fields+=entityField*)?)
	 */
	protected void sequence_entity(ISerializationContext context, entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns numericFieldType
	 *     numericFieldType returns numericFieldType
	 *
	 * Constraint:
	 *     (name=numericTypes constraints+=numericValidators*)
	 */
	protected void sequence_numericFieldType(ISerializationContext context, numericFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     numericValidators returns numericValidators
	 *
	 * Constraint:
	 *     (required=requiredValidator | minValue=minValidator | maxValue=maxValidator)
	 */
	protected void sequence_numericValidators(ISerializationContext context, numericValidators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     entityField returns primitiveField
	 *     primitiveField returns primitiveField
	 *
	 * Constraint:
	 *     (id=ID type=fieldType)
	 */
	protected void sequence_primitiveField(ISerializationContext context, primitiveField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KukulkanPackage.Literals.ENTITY_FIELD__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KukulkanPackage.Literals.ENTITY_FIELD__ID));
			if (transientValues.isValueTransient(semanticObject, KukulkanPackage.Literals.PRIMITIVE_FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KukulkanPackage.Literals.PRIMITIVE_FIELD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveFieldAccess().getIdIDTerminalRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getPrimitiveFieldAccess().getTypeFieldTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns stringFieldType
	 *     stringFieldType returns stringFieldType
	 *
	 * Constraint:
	 *     (name=stringType constraints+=stringValidators*)
	 */
	protected void sequence_stringFieldType(ISerializationContext context, stringFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stringValidators returns stringValidators
	 *
	 * Constraint:
	 *     (required=requiredValidator | minLenght=minValidator | maxLenght=maxValidator | pattern=patternValidator)
	 */
	protected void sequence_stringValidators(ISerializationContext context, stringValidators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
