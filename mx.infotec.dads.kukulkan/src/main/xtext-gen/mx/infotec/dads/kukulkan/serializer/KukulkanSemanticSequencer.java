/*
 * generated by Xtext 2.13.0
 */
package mx.infotec.dads.kukulkan.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mx.infotec.dads.kukulkan.kukulkan.KukulkanPackage;
import mx.infotec.dads.kukulkan.kukulkan.blobFieldType;
import mx.infotec.dads.kukulkan.kukulkan.blobValidators;
import mx.infotec.dads.kukulkan.kukulkan.booleanFieldType;
import mx.infotec.dads.kukulkan.kukulkan.dateFieldType;
import mx.infotec.dads.kukulkan.kukulkan.domainModel;
import mx.infotec.dads.kukulkan.kukulkan.entity;
import mx.infotec.dads.kukulkan.kukulkan.entityField;
import mx.infotec.dads.kukulkan.kukulkan.maxBytesValidator;
import mx.infotec.dads.kukulkan.kukulkan.numericFieldType;
import mx.infotec.dads.kukulkan.kukulkan.numericValidators;
import mx.infotec.dads.kukulkan.kukulkan.option;
import mx.infotec.dads.kukulkan.kukulkan.stringFieldType;
import mx.infotec.dads.kukulkan.kukulkan.stringValidators;
import mx.infotec.dads.kukulkan.services.KukulkanGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KukulkanSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KukulkanGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KukulkanPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KukulkanPackage.BLOB_FIELD_TYPE:
				sequence_blobFieldType(context, (blobFieldType) semanticObject); 
				return; 
			case KukulkanPackage.BLOB_VALIDATORS:
				sequence_blobValidators(context, (blobValidators) semanticObject); 
				return; 
			case KukulkanPackage.BOOLEAN_FIELD_TYPE:
				sequence_booleanFieldType(context, (booleanFieldType) semanticObject); 
				return; 
			case KukulkanPackage.DATE_FIELD_TYPE:
				sequence_dateFieldType(context, (dateFieldType) semanticObject); 
				return; 
			case KukulkanPackage.DOMAIN_MODEL:
				sequence_domainModel(context, (domainModel) semanticObject); 
				return; 
			case KukulkanPackage.ENTITY:
				sequence_entity(context, (entity) semanticObject); 
				return; 
			case KukulkanPackage.ENTITY_FIELD:
				sequence_entityField(context, (entityField) semanticObject); 
				return; 
			case KukulkanPackage.MAX_BYTES_VALIDATOR:
				sequence_maxBytesValidator(context, (maxBytesValidator) semanticObject); 
				return; 
			case KukulkanPackage.NUMERIC_FIELD_TYPE:
				sequence_numericFieldType(context, (numericFieldType) semanticObject); 
				return; 
			case KukulkanPackage.NUMERIC_VALIDATORS:
				sequence_numericValidators(context, (numericValidators) semanticObject); 
				return; 
			case KukulkanPackage.OPTION:
				sequence_option(context, (option) semanticObject); 
				return; 
			case KukulkanPackage.STRING_FIELD_TYPE:
				sequence_stringFieldType(context, (stringFieldType) semanticObject); 
				return; 
			case KukulkanPackage.STRING_VALIDATORS:
				sequence_stringValidators(context, (stringValidators) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     fieldType returns blobFieldType
	 *     blobFieldType returns blobFieldType
	 *
	 * Constraint:
	 *     (name=blobTypes constraints+=blobValidators*)
	 */
	protected void sequence_blobFieldType(ISerializationContext context, blobFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     blobValidators returns blobValidators
	 *
	 * Constraint:
	 *     (required=requiredValidator | minBytesValue=minBytesValidator | maxBytesValue=maxBytesValidator)
	 */
	protected void sequence_blobValidators(ISerializationContext context, blobValidators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns booleanFieldType
	 *     booleanFieldType returns booleanFieldType
	 *
	 * Constraint:
	 *     (name=BOOLEAN_TYPE required=requiredValidator*)
	 */
	protected void sequence_booleanFieldType(ISerializationContext context, booleanFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns dateFieldType
	 *     dateFieldType returns dateFieldType
	 *
	 * Constraint:
	 *     (type=dateTypes required=requiredValidator?)
	 */
	protected void sequence_dateFieldType(ISerializationContext context, dateFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     domainModel returns domainModel
	 *
	 * Constraint:
	 *     (entities+=entity+ | settings+=option)
	 */
	protected void sequence_domainModel(ISerializationContext context, domainModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     entityField returns entityField
	 *
	 * Constraint:
	 *     (id=ID type=fieldType)
	 */
	protected void sequence_entityField(ISerializationContext context, entityField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KukulkanPackage.Literals.ENTITY_FIELD__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KukulkanPackage.Literals.ENTITY_FIELD__ID));
			if (transientValues.isValueTransient(semanticObject, KukulkanPackage.Literals.ENTITY_FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KukulkanPackage.Literals.ENTITY_FIELD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityFieldAccess().getIdIDTerminalRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getEntityFieldAccess().getTypeFieldTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     entity returns entity
	 *     fieldType returns entity
	 *     entityType returns entity
	 *
	 * Constraint:
	 *     (name=ID tableName=ID? (fields+=entityField fields+=entityField*)?)
	 */
	protected void sequence_entity(ISerializationContext context, entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     maxBytesValidator returns maxBytesValidator
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_maxBytesValidator(ISerializationContext context, maxBytesValidator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KukulkanPackage.Literals.MAX_BYTES_VALIDATOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KukulkanPackage.Literals.MAX_BYTES_VALIDATOR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxBytesValidatorAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns numericFieldType
	 *     numericFieldType returns numericFieldType
	 *
	 * Constraint:
	 *     (name=numericTypes constraints+=numericValidators*)
	 */
	protected void sequence_numericFieldType(ISerializationContext context, numericFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     numericValidators returns numericValidators
	 *
	 * Constraint:
	 *     (required=requiredValidator | minValue=minValidator | maxValue=maxValidator)
	 */
	protected void sequence_numericValidators(ISerializationContext context, numericValidators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     option returns option
	 *
	 * Constraint:
	 *     setting=optionSetting
	 */
	protected void sequence_option(ISerializationContext context, option semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KukulkanPackage.Literals.OPTION__SETTING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KukulkanPackage.Literals.OPTION__SETTING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionAccess().getSettingOptionSettingParserRuleCall_0(), semanticObject.getSetting());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fieldType returns stringFieldType
	 *     stringFieldType returns stringFieldType
	 *
	 * Constraint:
	 *     (name=stringType constraints+=stringValidators*)
	 */
	protected void sequence_stringFieldType(ISerializationContext context, stringFieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stringValidators returns stringValidators
	 *
	 * Constraint:
	 *     (required=requiredValidator | minLenght=minLengthValidator | maxLenght=maxLengthValidator | pattern=patternValidator)
	 */
	protected void sequence_stringValidators(ISerializationContext context, stringValidators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
